\documentclass{article}

% Spacing
\usepackage{setspace}
\onehalfspacing{}

% Bibliography
\usepackage[american]{babel}
\usepackage[style=apa, citestyle=apa, backend=biber]{biblatex}
\DeclareLanguageMapping{american}{american-apa}
\addbibresource{references.bib}
\usepackage[babel,threshold=2]{csquotes}

% Title
\title{CMSC 124 Final Project}
\date{December 31, 2020}
\author{Tumulak, Patricia Lexa U., \\\and{} Valles, Oscar Vian L.}

% Table of Content
\setcounter{tocdepth}{2}

% Code Formatting
\usepackage{minted}
\usemintedstyle{pastie}

\newcommand{\js}[1]{\inputminted{javascript}{samples/js/#1.js}}
\newcommand{\rust}[1]{\inputminted{rust}{samples/rust/#1.rs}}
\newcommand{\jsin}[1]{\mintinline{javascript}{#1}}
\newcommand{\rustin}[1]{\mintinline{rust}{#1}}

\begin{document}

\pagenumbering{gobble}
\maketitle
\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Javascript}
\subsection{Purpose and Motivations}
JavaScript or JS was first made to provide a lightweight programming language
for NetScape that would make web development more accessible instead of
requiring deeper training. Today, it is now one of the most widely used
programming languages and is mainly used to build websites and web-based
applications. This is because it allows the creation of interactive elements for
web pages that enhances the user experience. While HTML and CSS give web pages
structure, JavaScript gives it responsiveness that engages the user. It is also
not limited to just web technology but is also used in game development and
mobile applications.

\subsection{History}

    \subsubsection{Mocha}
    JavaScript was developed by Brendan Eich in September 1995 when he was
    tasked to develop a “Scheme for the web browser” --- a simple, dynamic,
    lightweight, and powerful scripting language with syntax that resembled Java
    for NetScape. It would be accessible to non-developers such as designers.
    The first version of JavaScript was made in only just 10 days. JavaScript
    was originally named Mocha, then called LiveScript, and finally renamed to
    JavaScript in December 1995 to make it sound closer to Java and was
    presented as a scripting language for client-side tasks in the browser.

    \subsubsection{ES1 and 2}
    With Microsoft’s development of their own web browser, Internet Explorer,
    they developed their own language similar to Javascript called JScript. With
    the rapid growth of the internet, the need to standardize JavaScript was
    realized. NetScape tapped the European Computer Manufacturers Association
    (ECMA) to make a standardized language. In June 1997, the first version of
    the ECMAScript, labelled ECMA-262, was released. Due to trademark reasons,
    ECMA could not use JavaScript for the name of the standardized language and
    so, JavaScript is its commercial name.

    ECMAScript 2 or ES2 was released in June 1998 with relatively no new
    features to the language and only fixed a few inconsistencies between the
    ECMA and ISO standard for JavaScript.

    \subsubsection{ES3}
    ECMAScript 3 (or ES3) was released in December 1999 with changes to features
    were made such as regular expressions, exceptions and try/catch blocks,
    do-while block, the operators in and instanceof, and more.

    It was also during this time that AJAX (asynchronous JavaScript and XML) was
    born which was a technique that allowed pages to be updated asynchronously
    using JavaScript and browser built-in XMLHttpRequest object. The term AJAX
    was coined by Jesse James Garrett.

    \subsubsection{ES3.1 and ES4}
    As soon as ES3 was released in 1999, work on ES4 had already begun. The goal
    for this version of ECMAScript was to design features that allowed
    JavaScript to be used on the enterprise scale. However, conflict within the
    committee that worked on it (with representatives from Adobe, Mozilla,
    Opera, Microsoft, and Yahoo) started to arise. Some parties within expressed
    concern that ES4 was beginning to get “too big and was out of control”.
    These were words by Douglas Crockford, an influential JavaScript developer
    from Yahoo. Microsoft also supported Doug’s concerns and eventually, the
    group split off to work on ES4 and another separate idea called ES3.1 which
    was a simpler proposal with no new syntax and only practical improvements.
    ES4 ended up being too complex and was finally scrapped in 2008. Eventually
    ES4 found its way into the market as ActionScript developed by Adobe which
    was the scripting language supported by Flash.

    jQuery is a JavaScript library that was initially released in August 2006.
    Created by John Resig, it allows developers to add extra functionality to
    webpages. According to W3Techs, 74.4\% of the top 10 million websites use
    jQuery as of February 2020.

    NodeJS, a server-side runtime for JavaScript, was introduced in May 2009 by
    Ryan Dahl. This was built on Chrome’s V8 engine and it included an event
    loop. This helped build real-time web applications that scale. NodeJS also
    enabled developers to build a web app stack using only one programming
    language. This paradigm is called JavaScript Everywhere.

    \subsubsection{ES5}
    ECMAScript 3.1 was completed and released in December 2009, exactly 10 years
    after ES3. ECMAScript 3.1 was renamed ECMAScript 5 by the committee to avoid
    confusion. It was supported by Firefox 4, Chrome 19, Safari 6, Opera 12.10,
    and Internet Explorer 10. ES5 featured updates to the language such as
    getter/setters, reserved words, new methods for Object, Array, and Date,
    JSON support, among others. This did not require any changes to syntax.

    Another iteration of ES5 called ECMAScript 5.1 was released in 2011.
    However, this did not provide new features but only clarified ambiguous
    points.

    \subsubsection{ES6 (ES2015) and ES7 (ES2016)}
    2015 introduced a huge leap forward for JavaScript with the release of ES6
    or ES2015 with the introduction of features such as promises, let and const
    bindings, generators, classes, arrow functions, spread syntax, among others.

    It was also during 2015 that ReactJS, the framework that solidified modern
    day declarative UI patterns, was introduced. It took some concepts of
    AngularJS with declarative UI but improved them unidirectional data flow,
    immutability, and the use of the virtual DOM.\@

    June 2016 saw the release of the 7th edition of ECMAScript --- ES2016. This
    was a smaller release with few new features introduced such as the
    exponential operator (**), keywords for asynchronous programming and the
    Array.prototype.includes function.

    \subsubsection{ES8, 9, 10 (ES2017, 2018, 2019)}
    For the next three years, more features were added in subsequent editions of
    ECMAScript. This included but not limited to features such as functions for
    easy Object manipulation, rest/spread operators for object literals,
    asynchronous iteration, and changes to Array.sort and Object.fromEntries.

    \subsubsection{ES11 (ES2020)}
    Published in June 2020, ECMAScript 2020 included new functions, the
    primitive type BigInt for integers that were arbitrarily sized, the nullish
    coalescing operator, and the globalThis object.

    \subsection{Language Features}

    \subsubsection{Java-like syntax}
    JS shares syntax with Java such as the use of brackets, semicolons to end
    statements, return statements, if and do..while statements

    \subsubsection{Dynamic typing}
    JS supports dynamic typing, allowing a variable’s type to be
    determined/defined based on the value stored.

    \begin{figure}[ht]
      \js{dynamic-typing}
      \caption{Dynamic Types in JavaScript}
      \label{fig:dynamic-typing}
    \end{figure}

    Figure~\ref{fig:dynamic-typing} presents a case where different data types
    are stored in the same variable. This is allowed in JavaScript and no errors
    would be raised when this is run.

    \subsubsection{Prototypal Inheritance}
    Prototypal inheritance is a feature in JavaScript where each object has a
    special hidden property called \jsin{[[Prototype]]} that is a reference to
    another object or is null. This prototype serves as the basis of the current
    object. Whenever a property is read from an object and it is missing, the
    prototype provides the value of the object. Figure~\ref{fig:prototype}
    illustrates this.

    \begin{figure}[ht]
      \js{prototype}
      \caption{Dynamic Types in JavaScript}
      \label{fig:prototype}
    \end{figure}

    \subsubsection{Interpreted Language}
    JS script is interpreted by the JavaScript interpreter --- a built-in
    component of the web browser. In recent years however, just in time
    compilation is used for JS code such as in Chrome’s V8 engine.

    \subsubsection{Client-side validations}
    JS is a client-side scripting language. This means that JS functions can run
    even after the webpage has been loaded without communication with the server
    because the source code is processed by the client’s web browser instead of
    the web server. This makes JS very useful for things such as forms with the
    capability to validate errors in user input before sending the data to the
    server.

    \subsubsection{Arrow functions}
    Useful light-weight syntax that further simplified and shortened function
    syntax and lessened the number of lines of code.

    \subsubsection{Website Document Manipulation}
    The most common feature that JavaScript is used for is manipulating a
    website's document structure. This is made possible by using the Document
    Object Model (DOM)

    \begin{figure}[ht]
      \js{dom-manipulation}
      \caption{DOM Manipulation}
      \label{fig:dom-manipulation}
    \end{figure}

    Figure~\ref{dom-manipulation} is a basic example of how a website's content
    may be programmatically modified through the use of JavaScript.

  \subsection{Paradigms}
  JavaScript is a multi-paradigm language. It supports object-oriented
  programming, functional programming, and event-driven programming.

  \subsubsection{Object-Oriented Programming}
  JavaScript supports object-oriented programming through the use of object
  prototypes and prototypal inheritance. Objects in JavaScript are also mutable,
  meaning new instances of objects can be given new methods and properties.

  \begin{figure}[ht]
    \js{oop}
    \caption{Objects in JavaScript}
    \label{fig:oop}
  \end{figure}

  Figure~\ref{fig:oop} shows how a class is defined, an object is created and
  how a new property can be added in JavaScript

  \subsubsection{Functional Programming}
  The use of first-class functions, arrow functions (which are basically
  lambdas), and closures make the language functional as well.

  First-class functions can be passed as an argument to another function,
  returned from another function, and stored in an array, variable, or object.

  Lambdas (arrow functions in JavaScript) make code more succinct. It’s body can
  be an expression or a statement block.

  Closures are the collection of all variables within the scope of a function
  when it is created. It is the function and the lexical environment wherein the
  function was declared.

  \begin{figure}[ht]
    \js{arrow}
    \caption{Arrow Functions in JavaScript}
    \label{fig:arrow}
  \end{figure}

  Figure~\ref{fig:arrow} shows an arrow function being returned from another
  function. It is stored in a variable and is then executed. The arrow function
  retains the scope and environment where it was declared, making it work and
  still print the variable \jsin{num} to the console.

  \subsubsection{Event-Driven Programming}
  Event-driven programming is a paradigm wherein a program is designed to
  respond to events such as user’s actions. In JavaScript, this is usually done
  with an event loop and event listeners that listens or waits for these event
  triggers and then responds with an event handler which is a function that is
  called once an event is detected.

  \begin{figure}[ht]
    \js{events}
    \caption{Adding Event Listeners}
    \label{fig:events}
  \end{figure}

  Figure~\ref{fig:events} illustrates how an event listener is added to the
  document. This event listener calls the arrow function every time a
  \jsin{'wheel'} event is detected in the document.


  \subsection{Language Evaluation Criteria}

  \subsubsection{Simplicity}
  JavaScript, with its small number of primitive constructs and feature
  multiplicity, is highly writable. Due to this, its readability diminishes.
  However, JavaScript also does not support operator overloading, which also
  helps its readability.

  \subsubsection{Orthogonality}
  JavaScript is capable of executing operations on variables of different data
  types due to its dynamically typed nature. This gives the language high
  orthogonality. This implies that JavaScript is fairly readable in terms of
  orthogonality but a high degree of orgothanility diminishes its writability
  and its reliability. This is because errors might be undetected.


  \subsubsection{Data Types}
  JavaScript has a variety of different primitive data types including strings,
  numbers, booleans, null, undefined, symbol, and object. Data types in JS are
  also dynamically typed. Due to the data types not being explicitly defined,
  this makes it harder to read but also easier to write.

  \subsubsection{Syntax Design}
  JavaScript’s syntax design shares some similarities with Java such as the use
  of braces to start and end blocks of statements. JavaScript also uses a number
  of special and reserved words. This all helps enhance the language’s
  readability and writability.

  \subsubsection{Support for Abstraction}
  JavaScript supports abstraction since it allows the creation of classes,
  functions, and arrow functions. This makes it writable and reliable.

  \subsubsection{Expressivity}
  Functions that would require multiple lines of code in other languages such as
  C could be written and simplified in JavaScript with only a few lines because
  of the language having operators that make code succinct, making the language
  have high expressivity. This means the language is very writable as well as
  reliable.

  \subsubsection{Type Checking}
  JavaScript, being dynamically typed, makes it difficult to run type checks
  before program execution. There are some tools to conduct this but it adds
  another step to the process of building code. Type checking during execution
  also results in the performance suffering and a tendency for mistakes. This
  makes type checking in JavaScript not very reliable.

  \subsubsection{Exception Handling}
  JavaScript has measures for handling exceptions such as try-catch statements.
  This allows for intercepting run-time errors, making corrections, and
  continuing with execution. This makes the language reliable.

  \subsubsection{Restricted Aliasing}
  Every data type aside from the primitive types (strings, numbers, booleans,
  null, undefined, and symbol) are considered objects in JavaScript and are
  referred to as reference types. Aliasing is possible for objects, arrays, and
  functions since they are passed by reference. Due to this, its reliability
  suffers.

  \section{Rust}

  \subsection{Purpose}
  Rust was created by Graydon Hoare as a hobby in 2006. He described the
  language as “compiled, concurrent, safe, systems programming language”. This
  was initially developed to solve common problems in C and C++ that were
  related to memory management using built-in guards through the compiler and
  the design of the language. In addition, Graydon also added known and loved
  ideas from other languages into a systems language. He also wanted to revive
  old ideas from the 70s and 80s based on the theory that circumstances have
  changed and the design tradeoffs that used to favor C and C++ have shifted.

  Today, Rust has expanded into different industries and use cases. Some of
  these include embedded devices, command line interface tools, web assembly,
  and networking.

  \subsection{History}
  \subsubsection{The Personal Years (2006--2010)}
  Graydon Hoare started working on a compiled, concurrent, safe, systems
  programming language as a hobby and as a research project. These were some of
  the following descriptions that Hoare wrote as Rust was beginning: Memory
  Safety, Typestate system, Mutability control, Side-effect control, and Garbage
  Control. Some of these remained throughout the years, some were also scrapped.
  At this point, \textasciitilde90\% of the language features and
  \textasciitilde70\% of the runtime was roughly working.

  \subsubsection{The Graydon Years (2010--2012)}
  During this time, Rust was adopted by Mozilla for use in their Servo project.
  This project was a rewrite of the Gecko rendering engine used for Firefox.
  Development of both Servo and Rust was parallel. Features were dogfooded by
  the Rust and Servo team and the language was iterated upon based on the
  feedback from both teams. During this time period Graydon became a benevolent
  dictator for life-like figure for Rust, much like how Linus Trovald is a
  benevolent dictator for life-like figure for Linux.

  \subsubsection{The Typesystem Years (2012--2014)}
  During this time period, the team grew and incorporated more experts that had
  experience with advanced type systems. Due to this, the type system also grew
  as well. As the type system grew, functionality found in the language was
  transferred into libraries. In addition, the package manager of the language,
  Cargo, was also implemented during this period. At this time, Graydon stepped
  down from the project. This allowed the project to be able to democratically
  improve the project, since a singular authority to determine what is best for
  the language is not present.

  \subsubsection{The Release Years (2015--May 2016)}
  Rust released 1.0.0-alpha back on January 9, 2015, 1.0.0-beta1 on February 16,
  2015 and a 1.0.0 on May 15, 2015. The 1.0.0 release guarantees that Rust as a
  language will continue to change, but it will do so in a backwards-compatible
  manner. This meant that stability will be maintained in its various versions.
  Four aspects of the language were also improved during this period: ecosystem,
  tooling, stability, and community.

  \subsubsection{The Production Years (May 2016--Present)}
  Nowadays, Rust has released version 1.48.0 and is widely used in various
  industries. Companies like Firefox, Dropbox, Cloudfare, and NPM all use Rust
  in some form or another. Rust has also gained popularity in developer circles,
  being the most loved programming language for two years in a row, according to
  StackOverflow. The number of Crates found in Crates.io has also ballooned to
  51,833, as of December 30, 2020.

  \subsection{Language Features}

  This section is heavily based on the book \citetitle{klabnik_nichols_2018} by
  \cite{klabnik_nichols_2018}. Code examples are directly lifted from the book.

  \subsubsection{Immutability}
  In Rust, by default variables are immutable. In practice, once a value is
  bound to a name, the value cannot be changed. This prevents bugs where
  assumptions are made about values that will never change, but other parts of
  the code does change that value. The compiler guarantees that once a variable
  is declared to be immutable, it is immutable in all parts of the code.

  \begin{figure}[ht]
    \rust{immutability}
    \caption{Immutable Variable}
    \label{fig:immut}
  \end{figure}

  Figure~\ref{fig:immut} will result in a compilation error because x is
  reassigned a value. However, mutability of a variable may still be possible by
  adding the keyword \rustin{mut} before assigning the variable.

  \begin{figure}[ht]
    \rust{mutability}
    \caption{Mutability Declaration}
    \label{fig:mut}
  \end{figure}

  Figure~\ref{fig:mut} will now compile successfully and print the expected
  values.

  Even if variables are immutable by default, constants are also available in
  Rust. One key difference between variables and constants is the ability to be
  change its mutability. Variables can be mutable, while constants will always
  be immutable

  \subsubsection{Data Types}
  Rust is a statically typed language where the compiler needs to know the type
  of the variables at compile time. Despite that, it is not strongly typed. The
  compiler may infer the type based on what the value is and how it is used.
  Figure~\ref{fig:immut} shows this clearly where the type of the variable is
  not explicitly stated. However, there are cases where the compiler cannot
  accurately determine what the type is, hence a type annotation is required

  \begin{figure}[ht]
    \rust{annotations}
    \caption{Annotations on a Variable}
    \label{fig:annot}
  \end{figure}

  Figure~\ref{fig:annot} shows an example where the variable \rustin{guess} is
  given the annotation \rustin{u32} to show that the datatype of the variable is
  expected to be an unsigned 32bit integer. Otherwise, if not annotated, the
  compiler will spit out an error since the final type is not clear

  \subsubsection{Ownership}
  One of Rust's key defining feature is Ownership. It is a way for Rust to make
  memory safety guarantees without the need of a garbage collector. There are
  three main rules that Rust follows in handling ownership:

  \begin{itemize}
    \item Each value in Rust has a variable that’s called its owner.
    \item There can only be one owner at a time.
    \item When the owner goes out of scope, the value will be dropped.
  \end{itemize}

  These rules do not differ if the memory used is taken from the stack of from
  the heap. When the variable goes out of scope, the memory is always returned.

  However, there is a difference when copying values from one variable to
  another. An example of copying values from a variable in the stack is shown in
  Figure~\ref{fig:copy-stack}

  \begin{figure}[ht]
    \rust{copy-stack}
    \caption{Copying Variables from the Stack}
    \label{fig:copy-stack}
  \end{figure}

  This example is simple, since a new variable is created and the value is
  copied. After they go out of scope, both variables will be dropped. However,
  this is different when the variable is stored in a heap as shown in
  Figure~\ref{fig:copy-heap}

  \begin{figure}[ht]
    \rust{copy-heap}
    \caption{Copying Variables from the Heap}
    \label{fig:copy-heap}
  \end{figure}

  Variable \rustin{s1} is stored on the heap as the type \rustin{String} is
  dynamically allocated. When s1 is copied from \rustin{s2}, \rustin{s1} is
  invalidated and dropped. This is because when \rustin{s1} is copied into
  \rustin{s2}, the contents of the heap is not copied, only the pointer to the
  starting character and other data pertaining to \rustin{s1} is copied. If
  \rustin{s1} is not dropped, a double free may occur once both variables go out
  of scope. Hence, the first variable, \rustin{s1} is dropped. This effectively
  means that \rustin{s1} is moved to \rustin{s2}, instead of being copied.

  Rust also presents a way to deep copy the contents of a value stored on the
  heap through a method called \rustin{clone()}

  \subsubsection{Smart Pointers}
  The four most common smart pointers used in Rust are the following:
  \rustin{Box<T>}, \rustin{Rc<T>}, \rustin{RefCell<T>}

  \rustin{Box<T>} stores a pointer on the stack that points to data found on the
  heap. It can be used during the following situations:
  \begin{itemize}
    \item When a type's size is not known on compile time and a value of that
          type needs an exact size
    \item When a large amount of data needs to be stored and ownership needs to
          be transferred, but a copy should not happen.
  \end{itemize}

  \rustin{Rc<T>} allows values to have multiple owners. This type keeps track of
  the references that point to a value, and is destroyed when the number of
  references reaches zero.

  \rustin{RefCell<T>} is almost the same as \rustin{Box<T>}. The main difference
  from the two is the rules of ownership apply to \rustin{RefCell<T>} on
  runtime, rather than compile time. When the rules are broken on
  \rustin{Box<T>}, the compile errors out, when the rules are broken on
  \rustin{RefCell<T>}, the program panics and exits.

  \subsection{Paradigms}

  This section is heavily based on the book \citetitle{klabnik_nichols_2018} by
  \cite{klabnik_nichols_2018}. Code examples are directly lifted from the book.

  \subsubsection{Concurrent}
  Rust allows safe concurrency through the ownership and type systems that Rust
  has. These features of Rust allow the error-checking of the compiler to find
  concurrency errors during compile-time rather than at runtime.

  An simple example of a concurrent program is shown in Figure~\ref{fig:thread}:

  \begin{figure}[ht]
    \rust{thread}
    \caption{Spawning Multiple Threads}
    \label{fig:thread}
  \end{figure}

  \subsubsection{Functional}
  Rust has the following features that allow functional programming: Closures
  and Iterators.

  Closures are anonymous functions that can be saved in a variable or passed as
  arguments. They capture the scope from where they are defined. An example of a
  closure in Rust is shown in Figure~\ref{fig:closure}

  \begin{figure}[ht]
    \rust{thread}
    \caption{Closures in Rust}
    \label{fig:closure}
  \end{figure}

  Iterators are responsible for iterating over each item. An example of an
  iterator in Rust is shown in Figure~\ref{fig:iterator} where \rustin{v1_iter}
  is an iterator that iterate over the values in the vector \rustin{v1}

  \begin{figure}[ht]
    \rust{iterator}
    \caption{Iterators in Rust}
    \label{fig:iterator}
  \end{figure}

  \subsubsection{Generic}
  Rust allows generic programming through generics. Generics are stand-ins for
  other concrete types or properties that are not yet defined. A function with a
  Generic, shown in Figure~\ref{fig:generic}, where the function
  \rustin{largest<T>(list: &[T])}, can take any list with arbitrary data types
  like i32, u32, u8, etc. Generics are like templates found in C++.

  \begin{figure}[ht]
    \rust{iterator}
    \caption{Generics in Rust}
    \label{fig:generic}
  \end{figure}


  \subsubsection{Imperative}
  Rust is imperative by nature, as it was influenced by C and C++. All figures
  shown before present code that provide evidence of the imperative nature of
  Rust.

  \subsection{Language Evaluation Criteria}

  \subsubsection{Simplicity}
  Rust is not that simple, it has many basic constructs, with complicated
  concepts and meanings. Due to this Rust suffers from readability, writability,
  and reliability

  \subsubsection{Orthogonality}
  Rust is very orthogonal, every possible combination of primitives is possible.
  There is a very little amount of exceptions present in the language. This
  makes it very writable, readable, and reliable

  \subsubsection{Data Types}
  Rust's main feature is its robust data type system. Rust has adequate
  facilities for defining data types and structures through the usage of Structs
  and Generics. This gives great writability, readability, and reliability

  \subsubsection{Syntax Design}
  Rust's syntax design is based on C and C++, with additions from scripting
  languages and functional programming. It has explicit special words, but has
  truncated them. Most evidently with functions written as \rustin{fn}, mutable
  as \rustin{mut}, constant as \rustin{const}. Increasing writability but
  greatly reducing readability.

  \subsubsection{Support for Abstraction}
  Rust support for abstraction is great through functions and generics.

  \subsubsection{Expressivity}
  Rust is not that expressive, for the sake of achieving reliability. Most of
  the time, there is a singular 'Rust Way' of solving a problem. This way
  usually greatly reduces the errors that may occur and increases readability.
  One great example is the removal of the shorthand \mintinline{c++}{count++} in
  favor of \rustin{count = count + 1} or \rustin{x += 1} as it is less ambiguous
  for readers. This makes it more reliable, but less writable.


  \subsubsection{Type Checking}
  Due to its robust data type system, type checking is also very strong in Rust.
  It is not strongly typed, as variable types may be implied by the compiler but
  type annotations help when the compiler cannot find a unique type for a
  variable. Type checking is done at compile-time and is very thorough with
  expressive error messages. This makes rust very reliable.

  \subsubsection{Exception Handling}
  Exception handling in Rust is exemplary. The compiler enforces code to always
  handle error cases. However, Rust does not have exceptions, but rather has two
  types of errors. /rustin{Result<T,E>} for recoverable errors and a
  /rustin{panic!} macro for unrecoverable errors. This gives the programmer
  better ways to handle errors in the program. This greatly increases Rust's
  reliability.

  \subsubsection{Restricted Aliasing}
  Aliasing is very restricted in Rust because of one key feature in the
  language: Ownership. Ownership prevents a lot of errors that may occur due to
  aliasing. This is one of the main reasons for Rust's reliability

  \newpage
  \nocite{*} \printbibliography[heading=bibintoc,title={References}]{}

\end{document}
